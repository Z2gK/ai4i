<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Intro to Python for Data Science" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542451468.54" ts_lastsave="1542454833.41" unique_id="1">
		<rich_text>





</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Numpy basics" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542451543.36" ts_lastsave="1542454794.89" unique_id="2">
			<rich_text scale="h1">Creating numpy arrays</rich_text>
			<rich_text>

Lists can be converted to numpy arrays, but the numpy package has to be imported first.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Arithmetic operations</rich_text>
			<rich_text>

Arithmetic operations can be applied directly to numpy arrays.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Subsetting and Indexing</rich_text>
			<rich_text>

Numpy arrays can be subsetted and indexed.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">2D numpy arrays</rich_text>
			<rich_text>

2D numpy arrays can be created. These are just list of lists.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Basic statistical functions</rich_text>
			<rich_text>

Numpy also has basic statistical methods for objects, such as the following:
• numpy.mean()
• numpy.median()
• numpy.std()
• numpy.corrcoeff(... ,...)






</rich_text>
			<codebox char_offset="112" frame_height="100" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">import numpy as np
baseball = [180, 215, 210, 210, 188, 176, 209, 200]
np_baseball = np.array(baseball)</codebox>
			<codebox char_offset="202" frame_height="190" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create array from height with correct units: np_height_m
np_height_m = np.array(height) * 0.0254

# Create array from weight with correct units: np_weight_kg
np_weight_kg = np.array(weight) * 0.453592

# Calculate the BMI: bmi
bmi = np_weight_kg / np_height_m ** 2
</codebox>
			<codebox char_offset="274" frame_height="310" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create the light array
light = bmi &lt; 21

# Print out light
print(light)

# Print out BMIs of all baseball players whose BMI is below 21
print(bmi[light])

# Print out the weight at index 50
print(np_weight[50])

# Print out sub-array of np_height: index 100 up to and including index 110
print(np_height[100:111])</codebox>
			<codebox char_offset="357" frame_height="160" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">baseball = [[180, 78.4],
            [215, 102.7],
            [210, 98.5],
            [188, 75.2]]

# Create a 2D numpy array from baseball: np_baseball
np_baseball = np.array(baseball)
</codebox>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Intermediate Python for Data Science" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542453323.53" ts_lastsave="1542457044.44" unique_id="3">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Basic plotting with matplotlib" prog_lang="custom-colors" readonly="False" tags="matplotlib" ts_creation="1542453435.11" ts_lastsave="1542702403.26" unique_id="4">
			<rich_text scale="h1">Line and scatter plots</rich_text>
			<rich_text>

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


Plotting using pandas module. This also seem to work, from what it seems in other courses.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<codebox char_offset="24" frame_height="250" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">import matplotlib.pyplot as plt

# Make a line plot: year on the x-axis, pop on the y-axis
plt.plot(year,pop)

# Display the plot with plt.show() and then clean up
plt.show()
plt.clf()

# Change the line plot below to a scatter plot
plt.scatter(gdp_cap, life_exp)
</codebox>
			<codebox char_offset="120" frame_height="130" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import pandas as pd

# Plot 'Age' variable in a histogram
# data is a data series
pd.DataFrame.hist(data)
plt.show()
</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Pandas basics" prog_lang="custom-colors" readonly="False" tags="pandas" ts_creation="1542453803.32" ts_lastsave="1542456770.27" unique_id="5">
			<rich_text scale="h1">Building Pandas data frames</rich_text>
			<rich_text>

Pandas data frames can be built from lists with the aid of dictionaries.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Row labels can be specified.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


</rich_text>
			<rich_text scale="h1">Reading CSV data into data frames</rich_text>
			<rich_text>

Reading csv files can be done through read_csv method. An optional </rich_text>
			<rich_text weight="heavy">chunksize argument </rich_text>
			<rich_text>can be added to read the data in chunks. The index_col argument is used to specify the column in the file used for the row label, if any.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Basic square bracket indexing</rich_text>
			<rich_text>

Dataframes can be indexed and selected. Single brackets give a Series. Double brackets give a DataFrame. With just simple square bracketting, we cannot select both rows and columns at once though. Note that for row data selection, the use of row labels is not supported with this method.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


</rich_text>
			<rich_text scale="h1">More advanced loc and iloc indexing</rich_text>
			<rich_text>

If we want 2D functionalities we need to use the loc and iloc methods. 

We can select row data using the row labels

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

We can query individual elements, and take their intersection. To select all values, as usual, the “:” operator is used.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


</rich_text>
			<rich_text scale="h1">Logical subsetting</rich_text>
			<rich_text>

We can select data based on logical criteria using bracket subsetting. These return data frames.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Note special numpy logical functions have to be used when boolean operations are needed.
• numpy.logical_and()
• numpy.logical_or()
• numpy.logical_not()
</rich_text>
			<codebox char_offset="103" frame_height="295" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Pre-defined lists
names = ['United States', 'Australia', 'Japan', 'India', 'Russia', 'Morocco', 'Egypt']
dr =  [True, False, False, False, True, True, True]
cpc = [809, 731, 588, 18, 200, 70, 45]

# Import pandas as pd
import pandas as pd

# Create dictionary my_dict with three key:value pairs: my_dict
my_dict = {'country':names,'drives_right':dr,'cars_per_cap':cpc}

# Build a DataFrame cars from my_dict: cars
cars = pd.DataFrame(my_dict)
</codebox>
			<codebox char_offset="136" frame_height="130" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Definition of row_labels
row_labels = ['US', 'AUS', 'JAP', 'IN', 'RU', 'MOR', 'EG']

# Specify row labels of cars
cars.index = row_labels</codebox>
			<codebox char_offset="400" frame_height="115" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Import pandas as pd
import pandas as pd

# Fix import by including index_col
cars = pd.read_csv('cars.csv',index_col = 0)</codebox>
			<codebox char_offset="723" frame_height="280" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Print out country column as Pandas Series
print(cars['country'])

# Print out country column as Pandas DataFrame
print(cars[['country']])

# Print out DataFrame with country and drives_right columns
print(cars[['country','drives_right']])

# Print out first 3 observations
print(cars[0:3])

# Print out fourth, fifth and sixth observation
print(cars[3:6])</codebox>
			<codebox char_offset="882" frame_height="130" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Print out observation for Japan - this is pandas Series
print(cars.loc['JAP'])

# Print out observations for Australia and Egypt - this is a DataFrame
print(cars.loc[['AUS','EG']])</codebox>
			<codebox char_offset="1007" frame_height="190" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Print out drives_right value of Morocco - this should be a value
# If &quot;MOR&quot; is replaced by :, this would be a Series
print(cars.loc['MOR','drives_right'])

# Print sub-DataFrame
print(cars.loc[['RU','MOR'],['country','drives_right']])

# Print out cars_per_cap and drives_right as DataFrame
print(cars.loc[:,['cars_per_cap','drives_right']])</codebox>
			<codebox char_offset="1129" frame_height="385" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Convert code to a one-liner - the argument is a True/False Series
sel = cars[cars['drives_right']]


# Create car_maniac: observations that have a cars_per_cap over 500
cpc = cars['cars_per_cap']
many_cars = cpc &gt; 500
car_maniac = cars[many_cars]

# Need to import numpy and use the logical operators for more complex logic
import numpy as np
between = np.logical_and(cpc &gt; 100, cpc &lt; 500)
medium = cars[between]


</codebox>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Python Data Science Toolbox Part 1" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542457044.44" ts_lastsave="1542458096.74" unique_id="6">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Lambda functions and its uses" prog_lang="custom-colors" readonly="False" tags="lambda, map, reduce, filter" ts_creation="1542457086.4" ts_lastsave="1542458233.21" unique_id="7">
			<rich_text scale="h1">Lambda functions</rich_text>
			<rich_text>

Lambda functions need to be enclosed in round brackets when being defined. They are defined in the format:

lambda &lt;inputs&gt;: &lt;actions on inputs and value to return&gt;

Only one “line” is permitted for the lambda function definition.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


</rich_text>
			<rich_text scale="h1">Map</rich_text>
			<rich_text>

Map function takes a function and a sequence as its arguments and applies the function to every member of the sequence, and returns the resulting sequence.

Syntax: map(func, seq)
Returns: a sequence

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Filter</rich_text>
			<rich_text>

Filter function takes a function and a sequence as its input, and returns a sequence of members from the original sequence. Filter takes the function and evaluates it on every member of the input sequence. Those that evaluate to True will be returned in the output sequence.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text> 

</rich_text>
			<rich_text scale="h1">Reduce</rich_text>
			<rich_text>

Reduce function takes a function and a sequence as its arguments.

The input function needs to take two inputs and return return one output. Reduce takes the first two elements of the sequence and applies the function. Using the output of the function as one of the input, and the third element and the other input, the function is applied on these two elements. This is repeated until all the elements of the sequence are exhausted.

Note that reduce needs to be imported from functools.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


</rich_text>
			<codebox char_offset="250" frame_height="145" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Define echo_word as a lambda function: echo_word
echo_word = (lambda word1, echo: word1 * echo)

# Call echo_word: result
result = echo_word(&quot;hey&quot;,5)
</codebox>
			<codebox char_offset="460" frame_height="130" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings: spells
spells = [&quot;protego&quot;, &quot;accio&quot;, &quot;expecto patronum&quot;, &quot;legilimens&quot;]

# Use map() to apply a lambda function over spells: shout_spells
shout_spells = map(lambda s: s+&quot;!!!&quot;, spells)
</codebox>
			<codebox char_offset="747" frame_height="145" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'pippin', 'aragorn', 'boromir', 'legolas', 'gimli', 'gandalf']

# Use filter() to apply a lambda function over fellowship: result
result  = filter(lambda s: len(s)&gt;6, fellowship)
</codebox>
			<codebox char_offset="1249" frame_height="190" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Import reduce from functools
from functools import reduce

# Create a list of strings: stark
stark = ['robb', 'sansa', 'arya', 'brandon', 'rickon']

# Use reduce() to apply a lambda function over stark: result
result = reduce(lambda item1, item2: item1+item2,stark)
</codebox>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Python Data Science Toolbox Part 2" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542458096.74" ts_lastsave="1542554806.19" unique_id="8">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Iterators" prog_lang="custom-colors" readonly="False" tags="iterators, iterables" ts_creation="1542458105.24" ts_lastsave="1542459579.8" unique_id="9">
			<rich_text scale="h1">Iterators and iterables</rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h2">Iterables</rich_text>
			<rich_text>

Examples of iterables include 
• lists 
• strings 
• dictionaries
• file connections, etc.

Iterables can be iterated by directly using them in a for loop

for item in &lt;iterable&gt;:
    &lt;do things on item&gt;

They can be explicitly turned into a iterator object by applying iter() method. Under the hood, this is what the for loop is doing to iterables.


</rich_text>
			<rich_text scale="h2">Iterators</rich_text>
			<rich_text>

Iterators are objects that can be created from iterables via the iter method. Iterators have an associated next() method.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

This works on file connections as well, though we normally just use “for line in file:”

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Calling next() when there are no values left to return would give us a StopIteration error.

The splat operator * would return all the elements in the iterator all at once.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

An iterator can be created from a range object as well. The range function does not actually create a list in memory, which is good when we need to iterate over a large range.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>



</rich_text>
			<codebox char_offset="522" frame_height="220" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings: flash
flash = ['jay garrick', 'barry allen', 'wally west', 'bart allen']
# Create an iterator for flash: superspeed
superspeed = iter(flash)

# Print each item from the iterator
print(next(superspeed))
print(next(superspeed))
print(next(superspeed))
print(next(superspeed))
</codebox>
			<codebox char_offset="614" frame_height="100" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">file = open(&quot;file.txt&quot;)
it = iter(file)
print(next(it))
print(next(it))
...</codebox>
			<codebox char_offset="791" frame_height="160" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">word = &quot;Data&quot;
it = iter(word)
print(*it)
# Output:
# D a t a

# Doing this again would return an error
print(*it)</codebox>
			<codebox char_offset="971" frame_height="205" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create an iterator for range(10 ** 100): googol
googol = iter(range(10 ** 100))

# Print the first 5 values from googol - no errors here
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))
</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Enumerate" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542458136.12" ts_lastsave="1542460224.71" unique_id="10">
			<rich_text scale="h1">Enumerate</rich_text>
			<rich_text>

The enumerate function takes any iterable as its argument and returns a special enumerate object. The elements of this object consists of pairs with the index of the original member of the iterable, and the iterable itself.

This special enumerate object can be converted into a list.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


This enumerate object </rich_text>
			<rich_text weight="heavy">itself is an iterable</rich_text>
			<rich_text> and can be iterated over. The start index can be changed as well

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<codebox char_offset="297" frame_height="340" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings: mutants
mutants = ['charles xavier', 
            'bobby drake', 
            'kurt wagner', 
            'max eisenhardt', 
            'kitty pryde']

# Create a list of tuples: mutant_list
mutant_list = list(enumerate(mutants))

# Print the list of tuples
print(mutant_list)

# Output
# [(0, 'charles xavier'), (1, 'bobby drake'), (2, 'kurt wagner'), (3, 'max eisenhardt'), (4, 'kitty pryde')]
</codebox>
			<codebox char_offset="411" frame_height="310" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Unpack and print the tuple pairs
for index1, value1 in enumerate(mutants):
    print(index1, value1)
# Output
# 0 charles xavier
# 1 bobby drake
# 2 kurt wagner
# 3 max eisenhardt
# 4 kitty pryde

# Change the start index
for index2, value2 in enumerate(mutants, start=1):
    print(index2, value2)


</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Zip" prog_lang="custom-colors" readonly="False" tags="zip" ts_creation="1542458149.6" ts_lastsave="1542461575.85" unique_id="11">
			<rich_text scale="h1">Zip</rich_text>
			<rich_text>

Zip accepts an arbitrary number of iterables as its argument and returns a special zip object, which is also </rich_text>
			<rich_text weight="heavy">an iterator of tuples</rich_text>
			<rich_text>. Zip itself </rich_text>
			<rich_text weight="heavy">is an iterable</rich_text>
			<rich_text>.

Zip objects can be convert to a list of tuples.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

They can also be iterated over in a for loop.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

The zip object can be unpacked using the splat operator *.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

But this will exhaust the zip object and we have to create it again.</rich_text>
			<codebox char_offset="214" frame_height="280" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">mutants = ['charles xavier', 'bobby drake' ...]
aliases = ['prof x', 'iceman', ...]
powers = ['telepathy','thermokinesis',...]

# Create a list of tuples: mutant_data
mutant_data = list(zip(mutants, aliases, powers))

# Print the list of tuples
print(mutant_data)

# [('charles xavier', 'prof x', 'telepathy'), ('bobby drake', 'iceman', 'thermokinesis'), ('kurt wagner', 'nightcrawler', 'teleportation'), ('max eisenhardt', 'magneto', 'magnetokinesis'), ('kitty pryde', 'shadowcat', 'intangibility')]</codebox>
			<codebox char_offset="264" frame_height="100" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Unpack the zip object and print the tuple values
for value1,value2,value3 in mutant_zip:
    print(value1, value2, value3)
</codebox>
			<codebox char_offset="327" frame_height="205" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a zip object from mutants and powers: z1
z1 = zip(mutants,powers)

# Print the tuples in z1 by unpacking with *
print(*z1)

# ('charles xavier', 'telepathy') ('bobby drake', 'thermokinesis') ('kurt wagner', 'teleportation') ('max eisenhardt', 'magnetokinesis') ('kitty pryde', 'intangibility')
</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="List Comprehension" prog_lang="custom-colors" readonly="False" tags="list comprehension" ts_creation="1542458171.07" ts_lastsave="1542461873.74" unique_id="12">
			<rich_text scale="h1">Basic list comprehension</rich_text>
			<rich_text>

The list comprehension syntax generates a list </rich_text>
			<rich_text weight="heavy">from an iterable object</rich_text>
			<rich_text>. It applies a certain action to each member of the list. The output of that action would be the members of the new list.

List comprehension </rich_text>
			<rich_text weight="heavy">constructs the entire list and stores it in memory</rich_text>
			<rich_text>.

[ &lt;output expression&gt; for &lt;iterator variable&gt; in &lt;iterable&gt; ]

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

List comprehension are more efficient than for loops.

List comprehensions can replace nested for loops as well.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Advanced list comprehension</rich_text>
			<rich_text>

Conditionals can be added on at the iterable side.

[ &lt;output expression&gt; for &lt;iterator variable&gt; in &lt;iterable&gt; </rich_text>
			<rich_text weight="heavy">if &lt;condition&gt;</rich_text>
			<rich_text>]

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Or they can be added at the output expression side.

[ &lt;output expression&gt; </rich_text>
			<rich_text weight="heavy">if &lt;condition&gt;</rich_text>
			<rich_text> for &lt;iterator variable&gt; in &lt;iterable&gt;]

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
</rich_text>
			<codebox char_offset="354" frame_height="70" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create list comprehension: squares
squares = [i*i for i in range(0,10)]</codebox>
			<codebox char_offset="471" frame_height="100" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">pairs_2 = [(num1, num2) for num1 in range(0,2) for num2 in range(6,8)
print(pairs_2)
# Output
# [(0, 6), (0, 7), (1, 6), (1, 7)]
</codebox>
			<codebox char_offset="632" frame_height="145" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Create list comprehension: new_fellowship
new_fellowship = [member for member in fellowship if len(member)&gt;= 7]
</codebox>
			<codebox char_offset="765" frame_height="85" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create list comprehension: new_fellowship
new_fellowship = [member if len(member)&gt;=7 else &quot;&quot; for member in fellowship]
</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Generators" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542458177.9" ts_lastsave="1542462803.86" unique_id="13">
			<rich_text scale="h1">Generators from list comprehension syntax</rich_text>
			<rich_text> 

A basic generator can be obtained using the same syntax as list comprehension, except that we use () instead of [].

This creates a generator object which can be iterated over in a for loop. 

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

The next() function can also be applied to generator objects. Lazy evaluation - helps when working with large sequences and we don't want to store the entire sequence memory.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Conditional expressions that work for list comprehension also apply for generators.


</rich_text>
			<rich_text scale="h1">Generators from generator functions</rich_text>
			<rich_text>

Generator functions produce generator objects and are defined using def just like functions. instead of using return, we used yield in a generator function.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>




</rich_text>
			<codebox char_offset="237" frame_height="205" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings: lannister
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Create a generator object: lengths
lengths = (len(person) for person in lannister)

# Iterate over and print the values in lengths
for value in lengths:
    print(value)
</codebox>
			<codebox char_offset="416" frame_height="280" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create generator object: result
result = (num for num in range(0,31))

# Print the first 5 values
print(next(result))
print(next(result))
print(next(result))
print(next(result))
print(next(result))

# Print the rest of the values
for value in result:
    print(value)
</codebox>
			<codebox char_offset="700" frame_height="325" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Create a list of strings
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Define generator function get_lengths
def get_lengths(input_list):
    &quot;&quot;&quot;Generator function that yields the
    length of the strings in input_list.&quot;&quot;&quot;

    # Yield the length of a string
    for person in input_list:
        yield(len(person))

# Print the values generated by get_lengths()
for value in get_lengths(lannister):
    print(value)
</codebox>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="Importing Data in Python Part 1" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542554806.19" ts_lastsave="1542554823.12" unique_id="14">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Numpy" prog_lang="custom-colors" readonly="False" tags="numpy data import" ts_creation="1542554816.8" ts_lastsave="1542555952.79" unique_id="15">
			<rich_text scale="h1">Basic numpy data import</rich_text>
			<rich_text>

Importing as a numpy array. The object data is of type numpy.ndarray

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

delimiter: what delimiter is used for the data. Tab is \t
skiprows: how many header rows to skip at the start
usecols: which columns to import - in the example above, we are importing the first and third columns
dtype: what data type to use for all the data - in  the example above everything is imported as strings

Numpy is fine if all data is of the same type, but loadtxt breaks down if data is of mixed type.

</rich_text>
			<rich_text scale="h1">genfromtxt function</rich_text>
			<rich_text>

The numpy.genfromtxt() function is preferable for mixed type data.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

names: whether there is a header row.
dtype: if set to None, genfromtxt will figure out what each column should be

Here the object data is a structured array, where each element of this 1D array represents a row of the data

data[&lt;number&gt;] accesses a row
data[&lt;column label&gt;] accesses a column

</rich_text>
			<rich_text scale="h1">recfromcsv function</rich_text>
			<rich_text>

There is another function numpy.recfromcsv() that behaves similar to genfromtxt(). Its default arguments are as above in the genfromtxt() example, so we do not need to pass recfromcsv() any further arguments. The default dtype is None.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

</rich_text>
			<codebox char_offset="95" frame_height="100" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">import numpy as np
filename = &quot;file.txt&quot;
data = np.loadtxt(file, delimiter=&quot;,&quot;, skiprows=1, usecols=[0,2], dtype=str)</codebox>
			<codebox char_offset="602" frame_height="55" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">data = np.genfromtxt('titanic.csv', delimiter=',', names=True, dtype=None)</codebox>
			<codebox char_offset="1159" frame_height="55" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True">file = 'titanic.csv'
d=np.recfromcsv(file)
</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Pandas" prog_lang="custom-colors" readonly="False" tags="pandas flat file import" ts_creation="1542554823.12" ts_lastsave="1542702475.42" unique_id="16">
			<rich_text scale="h1">Basic pandas data import</rich_text>
			<rich_text>

Flat files can be imported in pandas.

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

nrows: number of rows to import
header: if set to None, there is no header row in the flat file. If set to 0, there is a header row and its column names are taken as default. The default behaviour is 0. Otherwise, the column names need to be specified in an argument names, a list of column names to use in the resulting data frame.
sep: field separator if not comma
comment: comment symbol, if used in the data frame
na_values: string used in flat file to indicate NA or NaN

</rich_text>
			<codebox char_offset="65" frame_height="145" frame_width="700" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="python3" width_in_pixels="True"># Import pandas as pd
import pandas as pd

# Assign the filename: file
file = 'titanic.csv'

# Read the file into a DataFrame: df
df = pd.read_csv(file, nrows=5, header=None, sep=&quot;\t&quot;, comment=&quot;#&quot;, na_values=&quot;Nothing&quot;)

</codebox>
		</node>
	</node>
</cherrytree>
